/**
 * Hexagon Background Animation
 * @author Feri Murdeni
 * @date 2025-05-09
 */
const canvas=document.getElementById("hexagonCanvas"),ctx=canvas.getContext("2d"),BASE_HEXAGON_WIDTH=100,BASE_HEXAGON_HEIGHT=110;let HEXAGON_WIDTH=100,HEXAGON_HEIGHT=110,HEXAGON_SIZE=HEXAGON_WIDTH/2,HORIZONTAL_SPACING=HEXAGON_WIDTH+4,VERTICAL_SPACING=HEXAGON_HEIGHT+8;function calculateResponsiveHexagonSize(){const t=window.innerWidth;let e=1;t<480?e=.5:t<768?e=.7:t<1024&&(e=.85),HEXAGON_WIDTH=100*e,HEXAGON_HEIGHT=110*e,HEXAGON_SIZE=HEXAGON_WIDTH/2,HORIZONTAL_SPACING=HEXAGON_WIDTH+4*e,VERTICAL_SPACING=HEXAGON_HEIGHT+8*e}let GRID_COLUMNS=0,GRID_ROWS=0;function resizeCanvas(){const t=window.devicePixelRatio||1;canvas.style.width="100%",canvas.style.height="100%",canvas.style.position="fixed",canvas.style.top="0",canvas.style.left="0",canvas.style.zIndex="-1",canvas.style.pointerEvents="none";const e=Math.max(document.documentElement.clientWidth,window.innerWidth||0),i=Math.max(document.documentElement.clientHeight,window.innerHeight||0);canvas.width=e*t,canvas.height=i*t,ctx.scale(t,t),calculateResponsiveHexagonSize(),calculateGridDimensions()}function calculateGridDimensions(){GRID_COLUMNS=Math.ceil(window.innerWidth/HORIZONTAL_SPACING)+3,GRID_ROWS=Math.ceil(window.innerHeight/VERTICAL_SPACING)+3}window.addEventListener("resize",(()=>{resizeCanvas(),void 0!==hexagonManager&&(hexagonManager.updateHexagonPositions(),hexagonManager.startContinuousRipple())})),window.addEventListener("scroll",(()=>{void 0!==hexagonManager&&(hexagonManager.targetScrollOffset=window.scrollY*hexagonManager.parallaxFactor)})),resizeCanvas(),calculateGridDimensions();class Hexagon{constructor(t,e){this.row=t,this.col=e,this.size=HEXAGON_SIZE,this.updatePosition(),this.opacity=0,this.targetOpacity=0,this.animationSpeed=.01+.01*Math.random(),this.lifespan=1e3+1e3*Math.random(),this.birthTime=Date.now(),this.isHovered=!1,this.hideAnimationSpeed=.01}updatePosition(){const t=this.row%2==1;this.x=t?this.col*HORIZONTAL_SPACING+HORIZONTAL_SPACING/2+HORIZONTAL_SPACING/2:this.col*HORIZONTAL_SPACING+HORIZONTAL_SPACING/2,this.y=this.row*(.75*VERTICAL_SPACING)+VERTICAL_SPACING/2}draw(){if(this.opacity<=0)return;ctx.save(),ctx.globalAlpha=.4*this.opacity,ctx.beginPath();const t=.9*HEXAGON_WIDTH,e=.9*HEXAGON_HEIGHT,i=t/2,a=this.x-i,o=this.y-e/2;ctx.moveTo(a+.5*t,o),ctx.lineTo(a+t,o+.25*e),ctx.lineTo(a+t,o+.75*e),ctx.lineTo(a+.5*t,o+e),ctx.lineTo(a,o+.75*e),ctx.lineTo(a,o+.25*e),ctx.closePath(),ctx.fillStyle="rgba(0, 0, 0, 0.1)",ctx.fill(),ctx.strokeStyle="rgba(255, 255, 255, 0.7)",ctx.lineWidth=1.5,ctx.stroke(),ctx.restore()}update(){const t=this.targetOpacity>this.opacity?this.animationSpeed:this.hideAnimationSpeed||this.animationSpeed;return this.opacity+=(this.targetOpacity-this.opacity)*t,this.opacity>.1&&this.lifespan>0&&(this.lifespan-=16.67,this.lifespan<=0&&!this.isHovered&&(this.targetOpacity=0)),Math.abs(this.opacity-this.targetOpacity)<.001&&(this.opacity=this.targetOpacity),this.opacity>.01}show(){this.targetOpacity=1,this.lifespan=1500*Math.random()+1500,this.animationSpeed=.01+.01*Math.random(),this.hideAnimationSpeed=.01,this.birthTime=Date.now()}setHovered(t){t&&!this.isHovered&&(this.targetOpacity=1,this.lifespan=400,this.animationSpeed=.1,this.hideAnimationSpeed=.05,this.birthTime=Date.now(),setTimeout((()=>{this.isHovered&&(this.targetOpacity=0)}),200)),this.isHovered=t}}class HexagonManager{constructor(){this.hexagons=[],this.hexagonGrid={},this.mouseX=0,this.mouseY=0,this.lastGroupShowTime=0,this.groupShowInterval=1500,this.isShowingGroup=!1,this.activeRipples=0,this.maxActiveRipples=2,this.continuousRippleActive=!1,this.continuousRippleQueue=[],this.scrollOffset=0,this.targetScrollOffset=0,this.parallaxFactor=.08,this.scrollEasing=.03,this.lastHexagonWidth=HEXAGON_WIDTH,this.lastHexagonHeight=HEXAGON_HEIGHT,window.addEventListener("mousemove",(t=>{const e=canvas.getBoundingClientRect();this.mouseX=t.clientX-e.left,this.mouseY=t.clientY-e.top})),this.createCompleteHoneycombGrid(),this.startContinuousRipple(),setTimeout((()=>this.showRandomHexagonGroup()),500),setTimeout((()=>this.showRandomHexagonGroup()),1e3)}createCompleteHoneycombGrid(){this.hexagons=[],this.hexagonGrid={};for(let t=-1;t<GRID_ROWS;t++)for(let e=-1;e<GRID_COLUMNS;e++){const i=`${t},${e}`,a=new Hexagon(t,e);a.opacity=0,a.targetOpacity=0,a.gridRow=t,a.gridCol=e,this.hexagonGrid[i]=a,this.hexagons.push(a)}this.lastHexagonWidth=HEXAGON_WIDTH,this.lastHexagonHeight=HEXAGON_HEIGHT}updateHexagonPositions(){if(Math.abs(this.lastHexagonWidth-HEXAGON_WIDTH)>1||Math.abs(this.lastHexagonHeight-HEXAGON_HEIGHT)>1){if(GRID_ROWS!==this.hexagons.length||GRID_COLUMNS!==this.hexagons[0]?.length)return void this.createCompleteHoneycombGrid();for(const t of this.hexagons)t.updatePosition();this.lastHexagonWidth=HEXAGON_WIDTH,this.lastHexagonHeight=HEXAGON_HEIGHT}}getNeighbors(t,e){const i=[],a=t%2==1,o=[[-1,a?0:-1],[-1,a?1:0],[0,-1],[0,1],[1,a?0:-1],[1,a?1:0]];for(const[a,s]of o){const o=t+a,n=e+s;if(o>=0&&o<GRID_ROWS&&n>=0&&n<GRID_COLUMNS){const t=`${o},${n}`,e=this.hexagonGrid[t];e&&i.push(e)}}return i}showRandomHexagonGroup(){if(this.activeRipples>=this.maxActiveRipples)return;const t=this.hexagons.filter((t=>t.opacity<.1));if(t.length>0){const e=t[Math.floor(Math.random()*t.length)],i=3;let a=!1;for(const t of this.hexagons)if(t.opacity>.1){const o=Math.abs(t.gridRow-e.gridRow),s=Math.abs(t.gridCol-e.gridCol);let n;if(n=e.gridRow%2==1===(t.gridRow%2==1)?Math.max(o,s):o+Math.max(0,s-Math.floor(o/2)),n<i){a=!0;break}}a?setTimeout((()=>this.showRandomHexagonGroup()),500):this.createRippleEffect(e.gridRow,e.gridCol,4)}}createRippleEffect(t,e,i){if(this.activeRipples>=this.maxActiveRipples)return;this.activeRipples++;const a=new Set,o=`${t},${e}`,s=this.hexagonGrid[o];if(s){s.show(),a.add(o);for(let o=1;o<=i;o++){const s=this.getHexagonsAtDistance(t,e,o,a),n=2e3*o,h=Array.from({length:s.length},((t,e)=>e));this.shuffleArray(h);s.slice(0,6).forEach(((t,e)=>{const a=h[e];setTimeout((()=>{t.show();setTimeout((()=>{if(t.targetOpacity=0,t.hideAnimationSpeed=.01,o===i){if(Math.random()<.25&&this.activeRipples<this.maxActiveRipples){setTimeout((()=>{this.createRippleEffect(t.gridRow,t.gridCol,2)}),2e3+300*a)}e===s.length-1&&setTimeout((()=>{this.activeRipples=Math.max(0,this.activeRipples-1)}),2500)}}),3e3+500*a)}),n+500*e)}))}}else this.activeRipples--}getHexagonsAtDistance(t,e,i,a){const o=[];for(let s=0;s<GRID_ROWS;s++)for(let n=0;n<GRID_COLUMNS;n++){const h=`${s},${n}`;if(a.has(h))continue;const r=this.hexagonGrid[h];if(!r)continue;const c=Math.abs(s-t),l=Math.abs(n-e);let g;g=t%2==1===(s%2==1)?Math.max(c,l):c+Math.max(0,l-Math.floor(c/2)),g===i&&(o.push(r),a.add(h))}if(o.length>8){const t=o[Math.floor(Math.random()*o.length)],e=[t],i=new Set([`${t.gridRow},${t.gridCol}`]);let a=[t];for(;e.length<8&&a.length>0;){const t=[];for(const s of a){for(const a of o){const o=`${a.gridRow},${a.gridCol}`;if(i.has(o))continue;const n=Math.abs(a.gridRow-s.gridRow),h=Math.abs(a.gridCol-s.gridCol),r=s.gridRow%2==1,c=a.gridRow%2==1;let l=!1;if(0===n&&1===h?l=!0:1===n&&(l=r===c?0===h:0===h||1===h),l&&(e.push(a),i.add(o),t.push(a),e.length>=8))break}if(e.length>=8)break}a=t}return e}return o}shuffleArray(t){for(let e=t.length-1;e>0;e--){const i=Math.floor(Math.random()*(e+1));[t[e],t[i]]=[t[i],t[e]]}return t}findClosestHexagon(t,e){if(t<0||t>canvas.width||e<0||e>canvas.height)return null;let i=null,a=1/0;for(const o of this.hexagons){const s=Math.sqrt(Math.pow(t-o.x,2)+Math.pow(e-o.y,2));s<a&&s<=1.5*HEXAGON_SIZE&&(a=s,i=o)}return i}update(){this.createContinuousRipples();const t=this.findClosestHexagon(this.mouseX,this.mouseY);this.hexagons.forEach((e=>{e.setHovered(e===t),e.update()}))}startContinuousRipple(){const t=Math.floor(Math.random()*GRID_ROWS),e=Math.floor(Math.random()*GRID_COLUMNS);this.createContinuousRippleEffect(t,e)}createContinuousRippleEffect(t,e){this.continuousRippleActive=!0,this.createRippleWithCallback(t,e,3,((t,e)=>{setTimeout((()=>{this.createContinuousRippleEffect(t,e)}),500)}))}createRippleWithCallback(t,e,i,a){const o=new Set,s=`${t},${e}`,n=this.hexagonGrid[s];if(!n){const t=Math.floor(Math.random()*GRID_ROWS),e=Math.floor(Math.random()*GRID_COLUMNS);return void a(t,e)}n.show(),o.add(s);let h=n;for(let s=1;s<=i;s++){const n=this.getHexagonsAtDistance(t,e,s,o),r=1e3*s,c=Array.from({length:n.length},((t,e)=>e));this.shuffleArray(c);const l=n.slice(0,6);l.forEach(((t,e)=>{const o=c[e];setTimeout((()=>{t.show(),s===i&&e===l.length-1&&(h=t);setTimeout((()=>{t.targetOpacity=0,t.hideAnimationSpeed=.01,t===h&&a(t.gridRow,t.gridCol)}),3e3+500*o)}),r+500*e)}))}}createContinuousRipples(){const t=Date.now();t-this.lastGroupShowTime>this.groupShowInterval&&(this.showRandomHexagonGroup(),this.lastGroupShowTime=t),this.activeRipples<this.maxActiveRipples&&this.showRandomHexagonGroup()}draw(){this.hexagons.forEach((t=>t.draw()))}}const hexagonManager=new HexagonManager;function animate(){ctx.clearRect(0,0,canvas.width,canvas.height),hexagonManager.scrollOffset+=(hexagonManager.targetScrollOffset-hexagonManager.scrollOffset)*hexagonManager.scrollEasing,ctx.save(),ctx.translate(0,-hexagonManager.scrollOffset),hexagonManager.update(),hexagonManager.draw(),ctx.restore(),requestAnimationFrame(animate)}animate();